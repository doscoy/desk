/* -------------------------------------------------------------------------------
	参照カウント付きスマートポインタです。
	保持しているポインタの参照数が０になった時に自動的に解放します。
---------------------------------------------------------------------------------*/


#ifndef HPP_SHARED_PTR_INCLUDED
#define HPP_SHARED_PTR_INCLUDED

// -----------------------------------------------------------------
//	インクルード
#include <algorithm>	// for std::swap
#include <cassert>		// for assert
#include <new>			// for new/delete

namespace nd {

// -----------------------------------------------------------------
//	クラス前方宣言
template <class T> class weak_ptr;



// =================================================================
//	参照カウントスマートポインタ
template <class T>
class shared_ptr
{
// -----------------------------------------------------------------
//	クラス内型定義
private:
	typedef shared_ptr<T> this_type;

// -----------------------------------------------------------------
//	公開型定義
public:
	typedef T element_type;
	typedef T value_type;
	typedef T* pointer;


// -----------------------------------------------------------------
//	コンストラクタ・デストラクタ
public:
	// *************************************************************************
	//	デフォルトコンストラクタ
	shared_ptr() 
		: px_( NULL )
		, pn_( NULL )
		{}

	// *************************************************************************
	//	コンストラクタ	ptr( p ) 形式でしか初期化してはいけません
	explicit shared_ptr(
		T* p		// I : 初期アドレス
		)
		: px_( NULL )
		, pn_( NULL ) {
		
		//	p に有効アドレスが指定されている場合に初期化
		if ( p ) {
			px_ = p;			// アドレスコピー
			pn_ = new int(1);	// 参照カウンタ生成
		}
	}

	// *************************************************************************
	//	コピーコンストラクタ  ptr = r 形式の初期化もOK
	shared_ptr( 
		const shared_ptr<T>& r	// シェアするポインタ
		)
		: px_( r.px_ )
		, pn_( r.pn_ ) 
		{
		
		if ( pn_ ){
			++(*pn_);
		}
	}
	
	// *************************************************************************
	//	コンストラクタ weak_ptrから作成
	explicit shared_ptr( 
		const weak_ptr<T>& r
		)
		: px_(r.px_)
		, pn_(r.pn_) 
		{}

	// *************************************************************************
	//	デストラクタ
	~shared_ptr()
	{
		if ( pn_ ) {
			if (--(*pn_) <= 0) {
				//	最後の参照が切れたので解放
				delete px_;
				px_ = NULL;
				
				delete pn_;
				pn_ = NULL;
				
	//			printf("解放！");
			}
		}
	}


// -----------------------------------------------------------------
//	オペレータ
public:
	// *************************************************************************
	//	コピー
	shared_ptr& operator =(
		const shared_ptr& r
		) {
	
		this_type( r ).swap( *this );
	
		return ( *this );
	}

	// *************************************************************************
	//	参照演算子
	T& operator *() const { 
		assert( px_ ); 
		return *px_; 
	}

	// *************************************************************************
	//	ポインタ演算子
	T* operator ->() const { 
		assert( px_ ); 
		return px_;
	}

	// *************************************************************************
	//	bool 演算子
	operator bool() const {
		return ( px_ != NULL );
	}
	bool operator !() const	{
		return ( px_ == NULL );
	}


// -----------------------------------------------------------------
//	公開メソッド
public:
	// *************************************************************************
	//	生ポインタ取得
	T* get() const {		// R : 生ポインタ
		return ( px_ );
	}
	
	// *************************************************************************
	//	リセット
	void reset( 
		T* p = NULL			// I : 引数
		) {
		if ( !p || ( p != px_ ) ){
			this_type( p ).swap( *this );
		}
	}

	// *************************************************************************
	//	参照カウント取得
	int useCount() const {	// R : 参照されている数
		return pn_ ? *pn_ : NULL;
	}
		
	// *************************************************************************
	//	所有権を共有している shared_ptr があるか判定
	bool isUnique() const {	// R : true = 自分以外に内容を共有しているshared_ptrが無い
		return ( useCount() == 1 );
	}
	
	// *************************************************************************
	//	交換
	void swap( 
		shared_ptr<T>& other	// I : 交換相手
		) {
		std::swap( px_, other.px_ );
		std::swap( pn_, other.pn_ );
	}
	
	// *************************************************************************
	//	< 判定関数
	//		関数名はboost準拠
	bool _internal_less( shared_ptr<T> const & rhs ) const {
		return ( pn_ < rhs.pn_ );
	}

// -----------------------------------------------------------------
//	メンバ変数
private:
	template<class Y> friend class weak_ptr;
    template<class Y> friend class shared_ptr;

	T* px_;
	int* pn_;
};


// *************************************************************************
//	比較オペレータ
template <class T> 
inline bool operator ==(
	const shared_ptr<T>& a,	// I : 比較対象1
	const shared_ptr<T>& b	// I : 比較対象2
	){
	//	同一アドレスかどうか
	return ( a.get() == b.get() );
}
template <class T> 
inline bool operator !=(
	const shared_ptr<T>& a,	// I : 比較対象1
	const shared_ptr<T>& b	// I : 比較対象2
	){
	return ( a.get() != b.get() );
}



} // namespace nd

#endif // HPP_SHARED_PTR_INCLUDED
